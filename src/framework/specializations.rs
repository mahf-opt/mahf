use serde::Serialize;

use crate::framework::common_state::Population;
use crate::framework::components::{AnyComponent, Component};
use crate::framework::{Individual, State};
use crate::problems::Problem;

/// Specialized component trait to initialize a new population on the stack.
///
/// # Implementing [Component]
///
/// Types implementing this trait can implement [Component] by wrapping the type in a [Initializer].
pub trait Initialization<P: Problem>: AnyComponent {
    fn initialize_population(&self, problem: &P, state: &mut State) -> Vec<Individual>;
}

#[derive(Serialize)]
pub struct Initializer<T>(pub T);

impl<T, P> Component<P> for Initializer<T>
where
    P: Problem,
    T: AnyComponent + Initialization<P> + Serialize,
{
    fn execute(&self, problem: &P, state: &mut State) {
        let population = self.0.initialize_population(problem, state);
        state.population_stack_mut().push(population);
    }
}

/// Specialized component trait to select a subset of the current population and push it on the stack.
///
/// # Implementing [Component]
///
/// Types implementing this trait can implement [Component] by wrapping the type in a [Selector].
pub trait Selection<P: Problem> {
    fn select_offspring<'p>(
        &self,
        population: &'p [Individual],
        problem: &P,
        state: &mut State,
    ) -> Vec<&'p Individual>;
}

#[derive(serde::Serialize)]
pub struct Selector<T>(pub T);

impl<T, P> Component<P> for Selector<T>
where
    P: Problem,
    T: AnyComponent + Selection<P> + Serialize,
{
    fn execute(&self, problem: &P, state: &mut State) {
        let population = state.population_stack_mut().pop();
        let selection: Vec<_> = self
            .0
            .select_offspring(&population, problem, state)
            .into_iter()
            .cloned()
            .collect();
        state.population_stack_mut().push(population);
        state.population_stack_mut().push(selection);
    }
}

/// Specialized component trait to generate a new population from the current one.
///
/// # Implementing [Component]
///
/// Types implementing this trait can implement [Component] by wrapping the type in a [Generator].
pub trait Generation<P> {
    fn generate_population(&self, population: &mut Vec<Individual>, problem: &P, state: &mut State);
}

#[derive(serde::Serialize)]
pub struct Generator<T>(pub T);

impl<T, P> Component<P> for Generator<T>
where
    P: Problem,
    T: AnyComponent + Generation<P> + Serialize,
{
    fn execute(&self, problem: &P, state: &mut State) {
        let mut population = state.population_stack_mut().pop();
        self.0.generate_population(&mut population, problem, state);
        state.population_stack_mut().push(population);
    }
}

/// Specialized component trait to replace the population with the child population,
/// typically generated by a [Selection] component.
/// Merges the two topmost populations on the stack.
///
/// # Implementing [Component]
///
/// Types implementing this trait can implement [Component] by wrapping the type in a [Replacer].
pub trait Replacement<P> {
    fn replace_population(
        &self,
        parents: &mut Vec<Individual>,
        offspring: Vec<Individual>,
        problem: &P,
        state: &mut State,
    );
}

#[derive(serde::Serialize)]
pub struct Replacer<T>(pub T);

impl<T, P> Component<P> for Replacer<T>
where
    P: Problem,
    T: AnyComponent + Replacement<P> + Serialize,
{
    fn execute(&self, problem: &P, state: &mut State) {
        let offspring = state.get_mut::<Population>().pop();
        let mut parents = state.get_mut::<Population>().pop();
        self.0
            .replace_population(&mut parents, offspring, problem, state);
        state.population_stack_mut().push(parents);
    }
}
