//! Mutation components for Differential Evolution (DE).

use std::marker::PhantomData;
use better_any::{Tid, TidAble};
use color_eyre::Section;
use derive_more::{Deref, DerefMut};
use eyre::{ensure, eyre};
use itertools::{multizip, Itertools};
use serde::Serialize;

use crate::{component::ExecResult, components::Component, population::AsSolutionsMut, problems::VectorProblem, utils::with_index, CustomState, State};
use crate::component::AnyComponent;
use crate::identifier::{Global, Identifier, PhantomId};

/// Applies the special DE mutation, similar to an arithmetic crossover.
///
/// Originally proposed for, and used as recombination in [`de`].
///
/// Requires a DE selection directly beforehand, e.g., [`DEBest`].
///
/// [`de`]: crate::heuristics::de
/// [`DEBest`]: crate::components::selection::de::DEBest
///
/// # Errors
///
/// Returns an `Err` if the population is not in the format generated by a DE selection.
#[derive(Clone, Serialize)]
pub struct DEMutation<I: Identifier = Global> {
    /// Number of difference vectors ∈ {1, 2}.
    pub y: u32,
    /// Difference vector scaling ∈ (0, 2], values for each individual in the population.
    pub f: f64,
    id: PhantomId<I>
}

impl<I: Identifier> DEMutation<I> {
    pub fn from_params(y: u32, f: f64) -> ExecResult<Self> {
        ensure!(
            [1, 2].contains(&y),
            "`y` needs to be one of {{1, 2}}, but was {}",
            y
        );
        ensure!(
            (0.0..=2.0).contains(&f),
            "`f` must be in [0, 2], but was {}",
            f
        );
        Ok(Self { y, f, id: PhantomId::default(), })
    }

    pub fn new_with_id<P>(y: u32, f: f64) -> ExecResult<Box<dyn Component<P>>>
    where
        P: VectorProblem<Element = f64>,
    {
        Ok(Box::new(Self::from_params(y, f)?))
    }
}

impl DEMutation<Global> {
    pub fn new<P>(y: u32, f: f64) -> ExecResult<Box<dyn Component<P>>>
    where
        P: VectorProblem<Element = f64>,
    {
        Self::new_with_id(y, f)
    }
}

impl<P, I> Component<P> for DEMutation<I>
where
    P: VectorProblem<Element = f64>,
    I: Identifier,
{
    fn execute(&self, _problem: &P, state: &mut State<P>) -> ExecResult<()> {
        if !state.contains::<SHADEParamF::<I>>() {
            let length = state.populations().current().len();
            state.insert(SHADEParamF::<I>::new(vec![self.f; length]));
        }
        let mut populations = state.populations_mut();
        let population = populations.current_mut();

        let size = (self.y * 2 + 1) as usize;

        if population.len() % size != 0 {
            return Err(eyre!("the population must be in the format [`y` * 2 + 1]*, where the first individual is the base of the mutation"))
                .suggestion("try to use an appropriate selection method for this mutation");
        }

        let mut solutions = population.as_solutions_mut();
        
        let f_vector = state.get_value::<SHADEParamF<I>>();

        for chunk in solutions.chunks_exact_mut(size) {
            match chunk {
                [ref mut base, remainder @ ..] => {
                    let pairs: Vec<[_; 2]> = remainder
                        .iter()
                        .chunks(2)
                        .into_iter()
                        .map(|pair| pair.collect_vec().try_into().unwrap())
                        .collect();

                    for [solution1, solution2] in pairs {
                        for (x, s1, s2, f) in
                            multizip((base.iter_mut(), solution1.iter(), solution2.iter(), f_vector.iter()))
                        {
                            *x += f * (s1 - s2);
                        }
                    }
                }
                _ => unreachable!(),
            }
        }

        population.retain(with_index(|i, _| i % size == 0));

        Ok(())
    }
}

/// F as vector for values for every individual in the population as used in JADE and SHADE.
#[derive(Clone, Deref, DerefMut, Tid)]
pub struct SHADEParamF<T: AnyComponent + 'static>(
    #[deref]
    #[deref_mut]
    Vec<f64>,
    PhantomData<T>,
);

impl<T: AnyComponent> SHADEParamF<T> {
    pub fn new(f: Vec<f64>) -> Self {
        Self(f, PhantomData)
    }
}

impl<T: AnyComponent> CustomState<'_> for SHADEParamF<T> {}