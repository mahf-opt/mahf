//! Replacement methods

use rand::seq::SliceRandom;
use rand::Rng;
use serde::{Deserialize, Serialize};

use crate::{
    components::Component,
    framework::{AnyComponent, Individual},
    problems::{Problem, SingleObjectiveProblem},
    state::State,
    CustomState,
};

/// Specialized component trait to replace the population with the child population,
/// typically generated by a [Selection](crate::components::selection::Selection) component.
/// Merges the two topmost populations on the stack.
///
/// # Implementing [Component]
///
/// Types implementing this trait can implement [Component] by wrapping the type in a [Replacer].
pub trait Replacement<P: Problem> {
    fn replace_population(
        &self,
        parents: &mut Vec<Individual<P>>,
        offspring: &mut Vec<Individual<P>>,
        state: &mut State<P>,
    );
}

#[derive(serde::Serialize, Clone)]
pub struct Replacer<T: Clone>(pub T);

impl<T, P> Component<P> for Replacer<T>
where
    P: Problem,
    T: AnyComponent + Replacement<P> + Serialize + Clone,
{
    fn execute(&self, _problem: &P, state: &mut State<P>) {
        let mut offspring = state.populations_mut().pop();
        let mut parents = state.populations_mut().pop();
        self.0
            .replace_population(&mut parents, &mut offspring, state);
        state.populations_mut().push(parents);
    }
}

/// Discards all individuals in the child population, keeping the parents unchanged.
#[derive(Serialize, Deserialize, Clone)]
pub struct Noop;

impl Noop {
    pub fn new<P: Problem>() -> Box<dyn Component<P>> {
        Box::new(Replacer(Self))
    }
}

impl<P: Problem> Replacement<P> for Noop {
    fn replace_population(
        &self,
        _parents: &mut Vec<Individual<P>>,
        _offspring: &mut Vec<Individual<P>>,
        _state: &mut State<P>,
    ) {
    }
}

/// Merges the parent and child populations.
#[derive(Serialize, Deserialize, Clone)]
pub struct Merge;

impl Merge {
    pub fn new<P: Problem>() -> Box<dyn Component<P>> {
        Box::new(Replacer(Self))
    }
}

impl<P: Problem> Replacement<P> for Merge {
    fn replace_population(
        &self,
        parents: &mut Vec<Individual<P>>,
        offspring: &mut Vec<Individual<P>>,
        _state: &mut State<P>,
    ) {
        parents.append(offspring);
    }
}

/// Always keeps the fittest individuals.
#[derive(Serialize, Deserialize, Clone)]
pub struct MuPlusLambda {
    /// Limits the population growth.
    pub max_population_size: u32,
}

impl MuPlusLambda {
    pub fn new<P: SingleObjectiveProblem>(max_population_size: u32) -> Box<dyn Component<P>> {
        Box::new(Replacer(Self {
            max_population_size,
        }))
    }
}

impl<P: SingleObjectiveProblem> Replacement<P> for MuPlusLambda {
    fn replace_population(
        &self,
        parents: &mut Vec<Individual<P>>,
        offspring: &mut Vec<Individual<P>>,
        _state: &mut State<P>,
    ) {
        parents.append(offspring);
        parents.sort_unstable_by_key(|i| *i.objective());
        parents.truncate(self.max_population_size as usize);
    }
}

#[cfg(test)]
mod mupluslambda {
    use crate::testing::*;

    use super::*;

    #[test]
    fn keeps_right_individuals() {
        let mut state = State::new();
        let comp = MuPlusLambda {
            max_population_size: 3,
        };
        let mut population = new_test_population(&[1.0, 3.0, 5.0]);
        let mut offspring = new_test_population(&[2.0, 6.0]);
        comp.replace_population(&mut population, &mut offspring, &mut state);
        let population = collect_population_objective_values(&population);
        assert_eq!(population.len(), comp.max_population_size as usize);
        assert_eq!(population, vec![1.0, 2.0, 3.0]);
    }
}

/// Always keeps the children.
#[derive(Serialize, Deserialize, Clone)]
pub struct Generational {
    /// Limits the population growth.
    pub max_population_size: u32,
}
impl Generational {
    pub fn new<P: Problem>(max_population_size: u32) -> Box<dyn Component<P>> {
        Box::new(Replacer(Self {
            max_population_size,
        }))
    }
}
impl<P: Problem> Replacement<P> for Generational {
    fn replace_population(
        &self,
        parents: &mut Vec<Individual<P>>,
        offspring: &mut Vec<Individual<P>>,
        _state: &mut State<P>,
    ) {
        parents.clear();
        parents.append(offspring);
        parents.truncate(self.max_population_size as usize);
    }
}

#[cfg(test)]
mod generational {
    use crate::testing::*;

    use super::*;

    #[test]
    fn keeps_all_children() {
        let mut state = State::new();
        let comp = Generational {
            max_population_size: 5,
        };
        let mut population = new_test_population(&[1.0, 3.0, 5.0, 6.0, 7.0]);
        let mut offspring = new_test_population(&[2.0, 4.0, 8.0, 9.0, 10.0]);
        comp.replace_population(&mut population, &mut offspring, &mut state);
        let population = collect_population_objective_values(&population);
        assert_eq!(population.len(), comp.max_population_size as usize);
        assert_eq!(population, vec![2.0, 4.0, 8.0, 9.0, 10.0]);
    }
}

/// Keeps random individuals from parents and children.
#[derive(Serialize, Deserialize, Clone)]
pub struct RandomReplacement {
    /// Limits the population growth.
    pub max_population_size: u32,
}
impl RandomReplacement {
    pub fn new<P: Problem>(max_population_size: u32) -> Box<dyn Component<P>> {
        Box::new(Replacer(Self {
            max_population_size,
        }))
    }
}
impl<P: Problem> Replacement<P> for RandomReplacement {
    fn replace_population(
        &self,
        parents: &mut Vec<Individual<P>>,
        offspring: &mut Vec<Individual<P>>,
        state: &mut State<P>,
    ) {
        parents.append(offspring);
        parents.shuffle(state.random_mut());
        parents.truncate(self.max_population_size as usize);
    }
}

#[cfg(test)]
mod random_replacement {
    use crate::state::Random;
    use crate::testing::*;

    use super::*;

    #[test]
    fn keeps_right_amount_of_children() {
        let mut state = State::new();
        state.insert(Random::testing());
        let comp = RandomReplacement {
            max_population_size: 5,
        };
        let mut population = new_test_population(&[1.0, 3.0, 5.0, 6.0, 7.0]);
        let mut offspring = new_test_population(&[2.0, 4.0, 8.0, 9.0, 10.0]);
        comp.replace_population(&mut population, &mut offspring, &mut state);
        let population = collect_population_objective_values(&population);
        assert_eq!(population.len(), comp.max_population_size as usize);
    }
}

/// Keeps the better individual from parent and offspring at the same index.
#[derive(Serialize, Deserialize, Clone)]
pub struct KeepBetterAtIndex;
impl KeepBetterAtIndex {
    pub fn new<P: SingleObjectiveProblem>() -> Box<dyn Component<P>> {
        Box::new(Replacer(Self))
    }
}
impl<P: SingleObjectiveProblem> Replacement<P> for KeepBetterAtIndex {
    fn replace_population(
        &self,
        parents: &mut Vec<Individual<P>>,
        offspring: &mut Vec<Individual<P>>,
        _state: &mut State<P>,
    ) {
        assert_eq!(parents.len(), offspring.len());

        for (parent, offspring) in parents.iter_mut().zip(offspring.drain(..)) {
            if parent.objective() > offspring.objective() {
                *parent = offspring;
            }
        }
    }
}
#[cfg(test)]
mod greedy_index {
    use crate::state::Random;
    use crate::testing::*;

    use super::*;

    #[test]
    fn keeps_right_amount_of_children() {
        let mut state = State::new();
        state.insert(Random::testing());
        let comp = KeepBetterAtIndex;
        let mut population = new_test_population(&[1.0, 3.0, 5.0, 6.0, 7.0]);
        let mut offspring = new_test_population(&[2.0, 4.0, 8.0, 9.0, 10.0]);
        let offspring_len = offspring.len();

        comp.replace_population(&mut population, &mut offspring, &mut state);
        assert_eq!(population.len(), offspring_len);
    }
}

#[derive(derive_more::Deref, derive_more::DerefMut, better_any::Tid, Default)]
pub struct Temperature(pub f64);
impl CustomState<'_> for Temperature {}

#[derive(Serialize, Deserialize, Clone)]
pub struct ExponentialAnnealingAcceptance {
    t_0: f64,
}

impl ExponentialAnnealingAcceptance {
    pub fn new<P: SingleObjectiveProblem>(t_0: f64) -> Box<dyn Component<P>> {
        Box::new(Self { t_0 })
    }
}

impl<P: SingleObjectiveProblem> Component<P> for ExponentialAnnealingAcceptance {
    fn initialize(&self, _problem: &P, state: &mut State<P>) {
        state.insert(Temperature(self.t_0));
    }

    #[contracts::invariant(state.populations().current().len() == 1, "population before and after should contain a single individual")]
    #[contracts::requires(state.populations().peek(1).len() == 1, "parent population should contain a single individual")]
    #[contracts::ensures(state.populations().len() == old(state.populations().len()) - 1)]
    fn execute(&self, _problem: &P, state: &mut State<P>) {
        let current = state.populations().peek(0).first().unwrap().objective();
        let candidate = state.populations().peek(1).first().unwrap().objective();

        let t = state.get_value::<Temperature>();
        let p = ((current.value() - candidate.value()) / t).exp();

        if candidate < current || state.random_mut().gen::<f64>() < p {
            let candidate_individual = state.populations_mut().pop();
            state.populations_mut().pop();
            state.populations_mut().push(candidate_individual);
        } else {
            state.populations_mut().pop();
        }
    }
}
